```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Palette Wizard for Photopea</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --gap:10px; --sw:36px; }
    *{ box-sizing:border-box; }
    body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; color:#e8e8e8; background:#0f1115; }
    header{ padding:14px 16px; border-bottom:1px solid #2a2e35; position:sticky; top:0; z-index:10; background:#0f1115; }
    h1{ font-size:16px; margin:0 0 6px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    label{ font-size:13px; }
    input[type=number],select{ padding:6px 8px; font-size:13px; border-radius:8px; border:1px solid #3a3f47; background:#151922; color:#e8e8e8; }
    input[type=number]{ width:90px; }
    button{ padding:8px 12px; border:1px solid #3a3f47; background:#151922; color:#e8e8e8; border-radius:8px; cursor:pointer; font-size:13px; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    main{ padding:14px 16px; display:grid; gap:16px; }
    .preview{ border:1px solid #2a2e35; border-radius:10px; padding:12px; display:grid; gap:8px; }
    .pv-head{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .pv-info{ font-size:12px; color:#9aa1ab; }
    .pv-wrap{ display:flex; gap:12px; align-items:center; }
    .pv-wrap canvas{ width:180px; height:auto; border-radius:6px; border:1px solid #2a2e35; background:#0a0c10; }
    section.palette{ border:1px solid #2a2e35; border-radius:10px; padding:12px; }
    .titlebar{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .titlebar h2{ font-size:14px; margin:0; }
    .swatches{ display:flex; gap:var(--gap); flex-wrap:wrap; }
    .sw{ width:var(--sw); height:var(--sw); border-radius:8px; border:1px solid #1e2228; }
    .hex{ font-family:ui-monospace,Menlo,Consolas,monospace; font-size:11px; color:#9aa1ab; }
    .row2{ display:flex; align-items:center; gap:10px; margin-top:10px; flex-wrap:wrap; }
    footer{ padding:10px 16px; border-top:1px solid #2a2e35; font-size:12px; color:#9aa1ab; }
  </style>
</head>
<body>
  <header>
    <h1>Palette Wizard</h1>
    <div class="row">
      <label for="k">Colors:</label>
      <input id="k" type="number" min="2" max="16" step="1" value="6" />
      <label for="src">Source:</label>
      <select id="src">
        <option value="doc" selected>Full document</option>
        <option value="layer">Current layer</option>
      </select>
      <button id="gen">Generate</button>
    </div>
  </header>

  <main>
    <section class="preview">
      <div class="pv-head">
        <strong>Analysis Preview</strong>
        <span class="pv-info" id="pvMeta">No data yet.</span>
      </div>
      <div class="pv-wrap">
        <canvas id="pvCanvas" width="1" height="1"></canvas>
        <div class="pv-info" id="pvDiag"></div>
      </div>
    </section>

    <section class="palette">
      <div class="titlebar"><h2>By Frequency</h2><button data-export="freq" disabled>Export to Photopea</button></div>
      <div class="swatches" data-swatches="freq"></div><div class="row2"><span class="hex" data-hex="freq"></span></div>
    </section>
    <section class="palette">
      <div class="titlebar"><h2>By Brightness</h2><button data-export="bright" disabled>Export to Photopea</button></div>
      <div class="swatches" data-swatches="bright"></div><div class="row2"><span class="hex" data-hex="bright"></span></div>
    </section>
    <section class="palette">
      <div class="titlebar"><h2>By Chroma</h2><button data-export="chroma" disabled>Export to Photopea</button></div>
      <div class="swatches" data-swatches="chroma"></div><div class="row2"><span class="hex" data-hex="chroma"></span></div>
    </section>
    <section class="palette">
      <div class="titlebar"><h2>By Hue</h2><button data-export="hue" disabled>Export to Photopea</button></div>
      <div class="swatches" data-swatches="hue"></div><div class="row2"><span class="hex" data-hex="hue"></span></div>
    </section>
  </main>

  <footer>Transparent pixels are ignored in analysis.</footer>

<script>
/* ================= Bridge with Photopea ================= */
let ppReady=false, waiter=null;
window.addEventListener("message", e => { 
  if(e.data==="done"){ 
    ppReady=true; 
    if(waiter){waiter(); waiter=null;} 
  }
});
try{ window.parent.postMessage("app.echoToOE('ping')","*"); }catch(e){}
function waitPP(){ return new Promise(r=>{ if(ppReady) r(); else waiter=r; }); }

/* ================= UI ================= */
document.getElementById("gen").addEventListener("click", async () => {
  try{ console.clear(); }catch(e){}
  await waitPP();
  setExport(false); 
  clearPalettes();

  const mode = document.getElementById("src").value; // "doc" | "layer"
  const ok = await requestPng(mode);
  if (!ok) {
    console.warn("No pixels captured (transparent/empty).");
    document.getElementById("pvMeta").textContent = "Failed to capture image";
    document.getElementById("pvDiag").innerHTML = "<div>No data received</div>";
  }
});

document.querySelectorAll('button[data-export]').forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const key = btn.getAttribute("data-export");
    exportPalette(lastPalettes[key]||[], `Palette-${key.toUpperCase()}.png`);
  });
});

function setExport(v){ 
  document.querySelectorAll('button[data-export]').forEach(b=>b.disabled=!v); 
}

function clearPalettes(){
  for(const key of ["freq","bright","chroma","hue"]){
    const sw=document.querySelector(`.swatches[data-swatches="${key}"]`); 
    if(sw) sw.innerHTML="";
    const hx=document.querySelector(`.hex[data-hex="${key}"]`); 
    if(hx) hx.textContent="";
  }
}

/* ================= Core export flow ================= */
async function requestPng(mode){
  let gotPNG=false, visJSON=null, pngData=null;
  let processed = false;

  const onMsg = async (e)=>{
    // Skip non-relevant messages
    if (e.data === "done" || processed) return;
    
    if (e.data instanceof ArrayBuffer) {
      // Got PNG - store it
      pngData = e.data;
      gotPNG = true;
      
      // If we already have visibility data, process now
      if (visJSON !== null && !processed) {
        processed = true;
        await processPNG(pngData, mode);
        restoreVisibility(visJSON);
      }
    } else if (typeof e.data === "string" && e.data.startsWith("__VIS__")) {
      visJSON = e.data.substring(7);
      
      // If we already have PNG data, process now
      if (gotPNG && pngData && !processed) {
        processed = true;
        await processPNG(pngData, mode);
        restoreVisibility(visJSON);
      }
    }
  };
  
  window.addEventListener("message", onMsg);

  const script = (mode==="layer") ? scriptCurrentLayerSolo() : scriptFullDocumentSolo();

  try{ 
    window.parent.postMessage(script,"*"); 
  }catch(e){ 
    window.removeEventListener("message", onMsg);
    return false; 
  }

  // Wait until both PNG and visibility data are received
  const ok = await new Promise(resolve=>{
    const timeout = setTimeout(()=>{ 
      window.removeEventListener("message", onMsg); 
      console.warn("Timeout waiting for response");
      resolve(false); 
    }, 5000);
    
    const checkInterval = setInterval(()=>{
      if (processed){
        clearTimeout(timeout); 
        clearInterval(checkInterval);
        window.removeEventListener("message", onMsg);
        resolve(true);
      }
    }, 50);
  });
  
  window.removeEventListener("message", onMsg);
  return ok;
}

async function processPNG(arrayBuffer, mode) {
  try {
    const img = await blobToImage(new Blob([arrayBuffer], {type:"image/png"}));
    drawPreview(img, mode);
    const {data,width,height} = imageToImageData(img, 768);
    const pixels = rgbaToRgbArray(data, 1);

    const diag = diagnose(pixels);
    document.getElementById("pvDiag").innerHTML =
      `<div>Non-transparent pixels: <b>${diag.count}</b></div>
       <div>Avg luminance: <b>${diag.avgY.toFixed(1)}</b></div>
       <div>Black ratio (&le;10): <b>${(diag.blackRate*100).toFixed(1)}%</b></div>`;

    if (diag.count>=10){
      runAllPalettes(data,width,height);
      setExport(true);
    } else {
      document.getElementById("pvDiag").innerHTML += 
        '<div style="color:#ff6b6b">Not enough pixels for analysis</div>';
    }
  } catch(e) {
    console.error("Error processing PNG:", e);
  }
}

/* ================= Photopea scripts (strings with real \n) ================= */
function scriptCurrentLayerSolo(){
  return [
    '(function(){',
    ' var d=app.activeDocument; ',
    ' if(!d){ app.echoToOE("No document"); return; }',
    ' var cl=d.currentLayer; ',
    ' if(!cl){ app.echoToOE("No current layer"); return; }',
    ' ',
    ' // Collect all layers in flat array',
    ' function walk(L,out){ ',
    '   for(var i=0;i<L.length;i++){ ',
    '     var ly=L[i]; ',
    '     out.push(ly); ',
    '     if(ly.layers && ly.layers.length) walk(ly.layers,out); ',
    '   } ',
    ' }',
    ' var all=[]; ',
    ' walk(d.layers, all);',
    ' ',
    ' // Save current visibility state',
    ' var prev=new Array(all.length); ',
    ' for (var i=0;i<all.length;i++){ ',
    '   prev[i]=!!all[i].visible; ',
    ' }',
    ' ',
    ' // Turn all layers OFF',
    ' for (var i=0;i<all.length;i++){ ',
    '   try{ all[i].visible=false; }catch(e){} ',
    ' }',
    ' ',
    ' // Turn on current layer',
    ' try{ cl.visible=true; }catch(e){}',
    ' ',
    ' // Turn on all parent groups up to document',
    ' var parent = cl.parent;',
    ' while(parent && parent !== d && parent.layers){',
    '   try{ parent.visible=true; }catch(e){}',
    '   parent = parent.parent;',
    ' }',
    ' ',
    ' // Force update',
    ' app.activeDocument.selection.selectAll();',
    ' app.activeDocument.selection.deselect();',
    ' ',
    ' // Save PNG',
    ' d.saveToOE("png");',
    ' ',
    ' // Send visibility data after a small delay',
    ' setTimeout(function(){',
    '   app.echoToOE("__VIS__"+JSON.stringify(prev));',
    ' }, 100);',
    '})();'
  ].join('\n');
}

function scriptFullDocumentSolo(){
  return [
    '(function(){',
    ' var d=app.activeDocument; ',
    ' if(!d){ app.echoToOE("No document"); return; }',
    ' ',
    ' function walk(L,out){ ',
    '   for(var i=0;i<L.length;i++){ ',
    '     var ly=L[i]; ',
    '     out.push(ly); ',
    '     if(ly.layers && ly.layers.length) walk(ly.layers,out); ',
    '   } ',
    ' }',
    ' var all=[]; ',
    ' walk(d.layers, all);',
    ' ',
    ' var prev=new Array(all.length); ',
    ' for (var i=0;i<all.length;i++){ ',
    '   prev[i]=!!all[i].visible; ',
    ' }',
    ' ',
    ' // Turn all layers ON',
    ' for (var i=0;i<all.length;i++){ ',
    '   try{ all[i].visible=true; }catch(e){} ',
    ' }',
    ' ',
    ' // Force update',
    ' app.activeDocument.selection.selectAll();',
    ' app.activeDocument.selection.deselect();',
    ' ',
    ' d.saveToOE("png");',
    ' ',
    ' // Send visibility data after a small delay',
    ' setTimeout(function(){',
    '   app.echoToOE("__VIS__"+JSON.stringify(prev));',
    ' }, 100);',
    '})();'
  ].join('\n');
}

/** Restore visibility exactly to the snapshot we got from Photopea */
function restoreVisibility(prevJson){
  const restore = [
    '(function(){',
    ' var d=app.activeDocument; ',
    ' if(!d) return;',
    ' ',
    ' function walk(L,out){ ',
    '   for(var i=0;i<L.length;i++){ ',
    '     var ly=L[i]; ',
    '     out.push(ly); ',
    '     if(ly.layers && ly.layers.length) walk(ly.layers,out); ',
    '   } ',
    ' }',
    ' var all=[]; ',
    ' walk(d.layers, all);',
    ' ',
    ' var prev='+prevJson+';',
    ' for (var i=0;i<all.length && i<prev.length;i++){ ',
    '   try{ all[i].visible = !!prev[i]; }catch(e){} ',
    ' }',
    '})();'
  ].join('\n');
  try{ window.parent.postMessage(restore,"*"); }catch(e){}
}

/* ================= Preview & diagnostics ================= */
function drawPreview(img, mode){
  document.getElementById("pvMeta").textContent =
    `Source: ${mode==="layer"?"Current layer":"Full document"} • ${img.width}×${img.height}px`;
  const cv=document.getElementById("pvCanvas");
  const maxW=320, s=img.width>maxW? maxW/img.width : 1;
  cv.width=Math.max(1,Math.round(img.width*s));
  cv.height=Math.max(1,Math.round(img.height*s));
  const cx=cv.getContext("2d",{willReadFrequently:true});
  cx.fillStyle="#0a0c10"; 
  cx.fillRect(0,0,cv.width,cv.height);
  cx.imageSmoothingEnabled=true;
  cx.drawImage(img,0,0,cv.width,cv.height);
}

function diagnose(pix){
  let n=0,sumY=0,blacks=0;
  for(const p of pix){ 
    const y=0.2126*p[0]+0.7152*p[1]+0.0722*p[2]; 
    if(y<=10) blacks++; 
    sumY+=y; 
    n++; 
  }
  return {count:n, avgY:n?sumY/n:0, blackRate:n?blacks/n:1};
}

/* ================= Palettes ================= */
const lastPalettes={freq:[],bright:[],chroma:[],hue:[]};

function runAllPalettes(data,w,h){
  const kRaw = parseInt(document.getElementById("k").value||"6",10);
  const pixels = rgbaToRgbArray(data, 1);
  const k = Math.max(2, Math.min(16, Math.min(kRaw, pixels.length || 2)));

  const freq   = kmeans(pixels, k);        
  lastPalettes.freq=freq;    
  render('freq',freq);
  
  const bright = brightnessPalette(pixels,k); 
  lastPalettes.bright=bright; 
  render('bright',bright);
  
  const chroma = chromaPalette(pixels,k);  
  lastPalettes.chroma=chroma; 
  render('chroma',chroma);
  
  const hue    = huePalette(pixels,k);     
  lastPalettes.hue=hue;      
  render('hue',hue);
}

function render(key, colors){
  const root=document.querySelector(`.swatches[data-swatches="${key}"]`);
  root.innerHTML = colors.map(c=>`<div class="sw" title="${hex(c)}" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>`).join('');
  const hx=document.querySelector(`.hex[data-hex="${key}"]`); 
  if(hx) hx.textContent = colors.map(hex).join('  ');
}

/* ================= Color / math ================= */
function hex([r,g,b]){ 
  const h=n=>Math.max(0,Math.min(255,n|0)).toString(16).padStart(2,'0').toUpperCase(); 
  return `#${h(r)}${h(g)}${h(b)}`; 
}

function rgbaToRgbArray(rgba, alphaMin=1){ 
  const out=[]; 
  for(let i=0;i<rgba.length;i+=4){ 
    if(rgba[i+3] < alphaMin) continue; 
    out.push([rgba[i],rgba[i+1],rgba[i+2]]);
  } 
  return out; 
}

function rgbToHsl([r,g,b]){ 
  r/=255; g/=255; b/=255; 
  const max=Math.max(r,g,b), min=Math.min(r,g,b); 
  let h=0,s=0,l=(max+min)/2; 
  if(max!==min){ 
    const d=max-min; 
    s=l>0.5? d/(2-max-min): d/(max+min); 
    switch(max){
      case r:h=(g-b)/d+(g<b?6:0);break;
      case g:h=(b-r)/d+2;break;
      default:h=(r-g)/d+4;
    } 
    h/=6;
  } 
  return [h*360,s,l]; 
}

function dist2(a,b){ 
  const dx=a[0]-b[0],dy=a[1]-b[1],dz=a[2]-b[2]; 
  return dx*dx+dy*dy+dz*dz; 
}

function avg(list){ 
  if(!list.length) return [0,0,0]; 
  let r=0,g=0,b=0; 
  for(const p of list){ r+=p[0]; g+=p[1]; b+=p[2]; } 
  const n=list.length; 
  return [Math.round(r/n),Math.round(g/n),Math.round(b/n)]; 
}

function sample(arr,n){ 
  if(arr.length<=n) return arr; 
  const out=[],step=arr.length/n; 
  for(let i=0;i<n;i++) out.push(arr[Math.floor(i*step)]); 
  return out; 
}

/* ================= K-means & palette helpers ================= */
function kmeans(pixels,k){
  const S=sample(pixels, Math.min(40000,pixels.length)); 
  if(!S.length) return Array.from({length:k},()=>[0,0,0]);
  
  const centers=[], used=new Set(); 
  while(centers.length<Math.min(k,S.length)){ 
    const i=Math.floor(Math.random()*S.length); 
    if(!used.has(i)){ 
      used.add(i); 
      centers.push(S[i].slice()); 
    } 
  }
  
  const assign=new Array(S.length).fill(0);
  for(let it=0; it<10; it++){
    for(let i=0;i<S.length;i++){ 
      let bi=0,bd=Infinity,p=S[i]; 
      for(let c=0;c<centers.length;c++){ 
        const d=dist2(p,centers[c]); 
        if(d<bd){bd=d;bi=c;} 
      } 
      assign[i]=bi; 
    }
    const sum=Array.from({length:centers.length},()=>[0,0,0,0]);
    for(let i=0;i<S.length;i++){ 
      const a=assign[i],p=S[i]; 
      sum[a][0]+=p[0]; 
      sum[a][1]+=p[1]; 
      sum[a][2]+=p[2]; 
      sum[a][3]++; 
    }
    for(let c=0;c<centers.length;c++){ 
      if(sum[c][3]){ 
        centers[c][0]=Math.round(sum[c][0]/sum[c][3]); 
        centers[c][1]=Math.round(sum[c][1]/sum[c][3]); 
        centers[c][2]=Math.round(sum[c][2]/sum[c][3]); 
      } 
    }
  }
  
  const counts=centers.map(()=>0);
  for(const p of S){ 
    let bi=0,bd=Infinity; 
    for(let c=0;c<centers.length;c++){ 
      const d=dist2(p,centers[c]); 
      if(d<bd){bd=d;bi=c;} 
    } 
    counts[bi]++; 
  }
  
  return centers.map((c,i)=>({c,w:counts[i]}))
    .sort((a,b)=>b.w-a.w)
    .map(x=>x.c)
    .slice(0,k);
}

function brightnessPalette(pixels,k){
  if(!pixels.length) return Array.from({length:k},()=>[0,0,0]);
  const arr=pixels.map(p=>({p,y:0.2126*p[0]+0.7152*p[1]+0.0722*p[2]}))
    .sort((a,b)=>a.y-b.y);
  return fairBuckets(arr,k).map(b=>avg(b.map(x=>x.p)));
}

function chromaPalette(pixels,k){
  if(!pixels.length) return Array.from({length:k},()=>[0,0,0]);
  let arr=pixels.map(p=>{ 
    const s=rgbToHsl(p)[1]; 
    return {p,s}; 
  }).sort((a,b)=>b.s-a.s);
  return fairBuckets(arr,k).map(b=>avg(b.map(x=>x.p)));
}

function huePalette(pixels,k){
  const bins=72, buckets=Array.from({length:bins},()=>[]);
  for(const p of pixels){ 
    const [h]=rgbToHsl(p); 
    const bi=Math.floor(((h%360)+360)%360/(360/bins)); 
    buckets[bi].push(p); 
  }
  const top=buckets.map((a,i)=>({i,n:a.length,a}))
    .sort((A,B)=>B.n-A.n)
    .slice(0,k)
    .sort((A,B)=>A.i-B.i);
  return top.map(b=>avg(b.a.length?b.a:[[0,0,0]]));
}

function fairBuckets(arr,k){
  const n=arr.length, base=Math.floor(n/k), extra=n%k, out=[]; 
  let idx=0;
  for(let i=0;i<k;i++){ 
    const size=Math.max(1, base+(i<extra?1:0)); 
    out.push(arr.slice(idx, idx+size)); 
    idx+=size; 
  }
  return out;
}

/* ================= Canvas / export helpers ================= */
function blobToImage(blob){ 
  return new Promise(res=>{ 
    const img=new Image(); 
    img.onload=()=>res(img); 
    img.src=URL.createObjectURL(blob); 
  }); 
}

function imageToImageData(img, maxLong=768){
  const long=Math.max(img.width,img.height), s=long>maxLong? maxLong/long:1;
  const w=Math.max(1,Math.round(img.width*s)), h=Math.max(1,Math.round(img.height*s));
  const cv=document.createElement("canvas"); 
  cv.width=w; 
  cv.height=h;
  const cx=cv.getContext("2d",{willReadFrequently:true});
  cx.drawImage(img,0,0,w,h);
  const id=cx.getImageData(0,0,w,h);
  return {data:id.data,width:w,height:h};
}

async function exportPalette(colors, filename){
  const sw=100,H=100,W=Math.max(1,colors.length*sw);
  const cv=document.createElement("canvas"); 
  cv.width=W; 
  cv.height=H;
  const cx=cv.getContext("2d");
  let x=0; 
  for(const c of colors){ 
    cx.fillStyle=`rgb(${c[0]},${c[1]},${c[2]})`; 
    cx.fillRect(x,0,sw,H); 
    x+=sw; 
  }
  const blob=await new Promise(res=>cv.toBlob(res,"image/png"));
  const ab=await blob.arrayBuffer();
  try{ window.parent.postMessage(ab,"*"); }catch(e){}
  setTimeout(()=>{ 
    try{ 
      window.parent.postMessage(`if(app.activeDocument) app.activeDocument.name="${filename.replace(/"/g,'')}"`,"*"); 
    }catch(e){} 
  },300);
}
</script>
</body>
</html>
